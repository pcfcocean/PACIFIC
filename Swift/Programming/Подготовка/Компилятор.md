#  Компилятор

AST - Abstract Syntax Tree (Абстрактное синтаксическое дерево)
IR - Intermediate Representation (Промежуточное представление)
SIL - Swift Intermediate Language
SSA - Static Single Assignment
LLVM - Low Level Virtual Machine


Compiler
- frontend = преобразование исходного кода в промежуточное представление IR + возможна оптимизация
  - middlend = выполняет оптимизацию (SIL)
    - backend = генерирует машинный код из оптимизированного промежуточного представления + оптимизация. Работает LLVM

 FRONTEND 8 этапов
 1 Lexer - лексический анализатор (лексер/токенизатор)
    С точки зрения компилятора файл с исходным кодом — это поток случайных символов, а может и какого-то мусора. Поэтому первый шаг — преобразование этих случайных символов в слова, которые допустимо использовать в языке программирования. Этим занимается лексический анализатор (лексер/токенизатор). Слова, которые он ищет, называются лексемами или токенами (не будем вдаваться в ненужные детали и примем эти термины синонимами). Поэтому этот процесс также называют токенизацией. Лексер производит анализ в соответствии с синтаксисом языка. Сканируя символ за символом, он находит соответствие исходного кода и правой части записи, а затем генерирует соответствующий токен из левой части.
    В Swift лексер является частью парсера

 2 Парсер - осуществляет синтаксический анализ. На вход ему передается последовательность токенов, а результатом работы является AST.

 3 Sema - семантический анализатор. Дерево AST, полученное от парсера, является грамматически верным, но в нём всё ещё могут быть ошибки. Например, в ходе парсинга нельзя (нецелесообразно) определить, что переменная объявлена до использования. Этим занимается семантический анализатор. Он проходит по всему дереву и присваивает типы выражениям, проверяет поддержку протоколов, синтезирует для структур инициализаторы по умолчанию и многое другое.
    Например при попытке присвоить значение типа Int в константу типа Bool. Swift такое не позволяет. Спасибо семантическому анализатору.

 4. Clang importer - На данном этапе происходит импорт Clang модулей и маппинг C и Objective-C API в соответствующие вызовы из Swift.
 
 Теперь у нас есть полностью разобранный исходный код, который прошёл первоначальную проверку. Но прежде чем переходить к генерации LLVM IR, нужно выполнить Swift специфичные оптимизации.
 
  5. SILGen - Следующий шаг — преобразование типизированного AST в сырой SIL. SIL — это специально созданное для Swift промежуточное представление. SIL имеет SSA форму. Static Single Assignment (SSA) — представление кода, в котором каждой переменной значение присваивается только один раз. Оно создаётся из обычного кода добавлением дополнительных переменных. Например, с помощью числового суффикса, который обозначает версию переменной после каждого присваивания. Благодаря этой форме компилятору проще оптимизировать код. Ниже приведён пример на псевдокоде. Очевидно, что первая строка является ненужной:
a = 1
a = 2
b = a

Но это только для нас. Чтобы научить компилятор это определять, пришлось бы писать нетривиальные алгоритмы. Но с помощью SSA сделать это гораздо проще. Теперь даже для простого компилятора будет очевидно, что значение переменной a1 не используется, и эту строку можно удалить:
a1 = 1
a2 = 2
b1 = a2

SIL позволяет применять к коду Swift специфичные оптимизации и проверки, которые было бы сложно или невозможно осуществить на этапе AST.
  
 6. SIL guaranteed transformations - Сырое промежуточное представление, которое было получено на прошлом этапе, анализируется на корректность и трансформируется в каноничное: функции, помеченные transparent, инлайнятся (вызов функции подменяется её телом), вычисляются значения константных выражений, выполняется проверка на то, что функции, которые возвращают значения, делают это во всех ветвлениях кода и так далее.
  Эти преобразования являются обязательными и выполняются, даже если оптимизация кода отключена.
 
 7. SIL optimization
 Дополнительные Swift-специфичные трансформации применяются, если включена оптимизация. Среди них специализация дженериков (оптимизация дженерик-кода под конкретный тип параметра), девиртуализация (замена динамических вызовов статическими), инлайнинг, оптимизация ARC и многое другое. Объяснение этих техник не влезает и в без того разросшуюся статью.
 
 8. LLVM IR Gen - Для фронтенда — это завершающий шаг. Генератор LLVM IR преобразует SIL в промежуточное представление LLVM. Оно передаётся в бекенд для дальнейшей оптимизации и генерации машинного кода.
 
 

Тюнинг Swift компилятора. Часть 1
https://habr.com/ru/articles/316986/

Устройство компилятора Swift. Часть 2
https://habr.com/ru/articles/317298/

Устройство компилятора Swift. Часть 3
https://habr.com/ru/companies/e-legion/articles/438696/

Устройство компилятора Swift. Часть 4
https://habr.com/ru/companies/e-legion/articles/440078/
