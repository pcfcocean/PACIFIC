#  Память

[*] Типы данных в Swift? - Ссылочные и Тип значения

[*] Примеры Ссылочных типов -Функции, замыкания, классы

[*] Примеры Типов значений - struct enum int double string set tuple array dict
[*] Что такое Стэк и Куча?
[*] Что хранится в куче, а что в стэке? - Референс тайп можно поместить в стек, если можно просчитать его размер

[*] Разница “==” и “===” - сравнение по значению, === - сравнение указателей в памяти.

[*] ARC (weak, strong …)
[*] На что указывают strong, unowned и weak? - strong и unowned указывают на объект, а weak на side table

[*] Жизненный цикл объекта в Swift?
Ответ: https://habrastorage.org/r/w1560/getpro/habr/upload_files/f39/986/7c0/f399867c0e27ed62e006d84c60a42223.png
1.    LIVE - Объект жив, все хорошо
2.    DEINITING - вызван метод deinit(), после завершения методы deinit() вызывается swift_deallocObject, который в свою очередь вызывает метод canBeFreeNow()
    Если есть side table или unowned ссылоки тогда этот метод всегда вернет false и переход в стадию DEINITED,
    иначе, если вернет true переход в состояние DEAD
    В состоянии DEINITING уже невозможны операции с strong ссылками, при попытке чтении unowned ссылок будет срабатывать assertion failure, однако сохранение unowned ссылок будет работать штатно
    Если canBeFreeNow() вернул false - происходит декремент unowned ссылок и объект переходит в стадию DEINITED
3.    DEINITED - В этот момент еще остались unowned ссылки, но уже невозможно их сохранение, когда счетчик unowned ссылок достигает нуля, объект высвобождается и становится DEAD
    Если есть side table операции с weak ссылками не выполняются, когда счетчик unowned ссылок становится равным нулю, объект освобождается
    , счетчик weak ссылок декрементируется и объект переходит в стадию FREED
4.    FREED - без side tale никогда не возникает
    Объект высвобожден, но есть weak ссылки на side table, операции с weak ссылками невозможны, когда счетчик weak ссылок достигает нуля, боковая таблица высвобождается и объект переходит в стадию DEAD
5.    DEAD - Объект и его side table полностью исчезли

[*] SideTable, как устроена, когда создается и когда уничтожается?
    Создается после появления первой weak ссылки на объект, при переполнении счетчиков strong и unowned ссылок, если для объекта требуется связанное хранилище объектов (associated object storage)

[*] Уничтожается после высвобождения всех weak ссылок в стадии FREED объекта.

[*] Влияет ли порядок расположения полей в структуре на объем выделяемой памяти под эту структуру? - Да

[*] Как происходит процесс вычисления необходимого объема памяти для хранения структуры, на примере структур
Структура А: имеет 3 поля String, Int, Bool
Структура Б: имеет 3 поля Bool, String, Int

Ответ: Для структуры А размер вычисляется достаточно просто — это сумма всех его полей. String занимает 16 байт, Int — 8 байт, а Bool — 1 байт == 25 байт.
Для структуры Б размер вычисляется иначе, в ней Bool занимает 8 байт, String — 16 байт, а Int — 8 байт == 32 байт.

[*] Почему при изменении порядка полей в структуре изменяется объем выделенной под нее памяти?
Ответ: stride (шаг) и alignment (выравнивание).
Шаг (Stride) - определяет промежуток между элементами, который всегда будет больше или равен размеру объекта. Благодаря шагу мы знаем, на сколько байтов нужно двигать указатель, чтобы добраться до следующего объекта. 
Шаг считается просто — это размер округленный в большую сторону, кратный выравниванию. Именно поэтому при размере структуры равному 9 (Int + Bool) байт следующим числом, кратным 8, будет 16.
Выравнивание (alignment) -  это значение кратно которому должен быть байт с которого должен начинаться объект поля в структуре, например, если сначала в структуре идет тип Bool размером 1 байт, то для того, чтобы машине понимать, где же находится тип Int с размером в 8 байт нужно обратиться к выравниванию большего из типов, то есть Int, которое равно 8, таким образом, хоть Bool и занимает 1 байт все равно потребуется переместиться на восьмой байт (т.к. он ближний байт кратный выравниванию у типа Int), что оставит байты с 1 по 7 пустыми.
Выравнивание всей структуры рассчитывается достаточно просто — это наибольшее выравнивание из всех свойств. Если мы заменим Int на Int32, у которого выравнивание равно 4, то и вся структура будет иметь выравнивание 4.

[*] Задача: Есть комплишене в комплишене, во внешнем комплишене ослаблен self нужно ли его ослаблять во внутреннем? 
[*] Что такое механизм Copy On Write? (Применим только к коллекциям словарям и массивам)
Ответ: Механизм Copy-on-Write применяется только к коллекциям и только при мутации такого объекта. (и только если на такой объект имеется более одной ссылки, иначе объект можно было бы просто изменить по ссылке и никакое копирование бы не требовалось)

[*] Поверхностное и глубокое копирование, что это и в чем различия?
Ответ: 
Поверхностное (или мелкое) — создается новая коллекция, которая хранит ссылки на объекты внутри этой коллекции. Если привести пример, то представьте что у вас есть массив с типом class. В этом массиве несколько объектов. При поверхностном копировании создается новый массив, но объекты в нем не будут созданы заново, они будут просто скопированы по ссылке (то есть объекты будут указывать на одну и ту же область памяти, что и объекты исходного массива).

Глубокое — создается новая коллекция, которая хранит копии на объекты внутри этой коллекции. То есть объекты внутри коллекции будут указывать на разные области в памяти по сравнению с исходным массивом.

[*] Копирование массива с class объектами и struct объектами, в чем разница?
[*] Плюсы и минусы lazy инициализации
[*] Что такое зомби объекты? - До Swift 4
[*] Является ли синглтон потокобезопасным? - да т.к. static let - константа
