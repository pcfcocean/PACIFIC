#  Блок многопоточности

[*] Что такое многопоточность? - процесс параллеьного выполнения задач в разных потоках
[*] Какие бывают виды многопоточности? - Ответ: Физическая и виртуальная
[*] Что такое физическая многопоточность?
[*] Что такое виртуальная многопоточность?
[*] Как реализована многопоточность на уровне процессора?
Ответ: Фактически, ЦП может обрабатывать только один поток. То есть только один поток будет работать в каждый момент времени. ЦП быстро переключается между несколькими потоками. Таким образом, ЦП создает впечатление многопоточного одновременного выполнения задач.

[*] Что такое очередь? - это сущность выполняющую задачи, поступающие на вход, на одном или множестве потоков
[*] Какие бывают очереди в Swift?
  Серийные (Serial) очереди выполняют одну задачу за другой
  Сoncurrent (параллельная) – выполняет задачи параллельно.

[*] Разница global и main очередей
    global - это системную concurrent очередь с приоритетом default.
    main - это главную очередь она serial очередью

[*] Последовательные и параллельные очереди
// Парллельная очередь (параллельные потоки)
// Thread1---------------
// Thread2---------------

// Последовательная очередь (последовательные потоки)
// Thread1-------       ------------
// Thread2       -------

[*] Синхронность и асинхронность

[*] qos классы
// Quality of Service
// QOS_CLASS_USER_INTERACTIVE - пользователь взаимодействует с UI. Юзер ждет результата выполенения прямо сейчас
// QOS_CLASS_USER_INITIATED - нужно сделать: но не внутри интерактивного события, но не затягивая
// QOS_CLASS_DEFAULT - среднее между QOS_CLASS_USER_INTERACTIVE и QOS_CLASS_USER_INITIATED
// QOS_CLASS_UTILITY - задачи в фоновом режиме с более длительны временем исполнения (пример очистка БД, кеша)
// QOS_CLASS_BACKGROUND - Нет точного времени выполнения потока (фоновый режим по доступности ресурсов системы)
// QOS_CLASS_UNSPECIFIED - отсутствие QOS

[*] Самый низкоприоритетный qos-класс?
[*] Самый высокоприоритетный qos-класс?
14.    Есть 2 очереди: userInteractive и background, на которых выполняются задачи асинхронно. Что произойдет, если в background очередь добавить синхронную задачу?
Ответ: Синхронная операция - это операция высокого приоритета, поэтому, даже если очередь background, но в нее поместить sync задачу, то все другие async задачи в этой очереди должны будут сначала завершиться, а потом запустить sync задачу, это автоматически увеличивает приоритет у задач в этой очереди и даже если ДО этих задач были запущены async задачи на userInteractive очереди, то у задач userInteractive очереди будет более низкий приоритет, чем у задач в background очереди в конкретно такой ситуации.

[*] Что такое голодание в очередях?
Ответ: Когда пул-потоков GCD закончился и каждой новой очереди не будет выделен поток, т.к. они уже закончились, следовательно задача никогда не будет выполнена.

[*] Максимальное количество потоков в GCD?
Ответ: 66, 1 main, 1 не связанный с GCD и 64 пул потоков для GCD

[*] Какое максимальное количество объектов типа Thread можно запустить на выполнение? - Сколько угодно, ограничением является возможности системы.

[*] Блочит ли синхронное выполнение задачи в очереди внешнюю очередь? - Блочит, если внешняя последовательная

[*] DispatchGroup, что такое и как использовать? 
[*] Что такое Semaphore?
[*] Как работает DispatchSemaphore?
[*] Что такое мьютекс? - механизм блокировки потока
[*] Пример работы мьютекса? 
[*] Что такое потокобезопасная структура данных?
[*] Как сделать потокобезопасную структуру данных, например массив?

[*] Задача: С бэкенда пришло 1 миллион строк, нужно их обработать по какому-то правилу и показать пользователю, что будешь делать?

[*] Задача: Нужно получить синхронный ответ от функции, которая в свою очередь делает запрос на бэкенд, как этого достичь?

// Условия гонки [Race condition]: С несколькими потоками, при работе с одними данными, в результате чего сами данные становятся непредсказуемыми и зависят от порядка выполнения потоков.
// Конкуренция за ресурс [Resource contention]: Несколько потоков, выполняющих разные задачи, пытаются получить доступ к одному ресурсу, тем самым увеличивая время необходимое для безопасного получения ресурса. Эта задержка может привести к непредвиденному поведению.
// Вечная блокировка [Deadlock]: Несколько потоков блокируют друг друга.
// Голодание [Starvation] : Поток не может получить доступ к ресурсу и безуспешно пытается сделать это снова и снова.
// Инверсия приоритетов [Priority Inversion]: Поток с низким приоритетом удерживает ресурс, которые требуется другому потоку с более высоким приоритетом.
// Неопределенность и справедливость [Non-deterministic and Fairness]: Мы не можем делать предположений, когда и в каком порядке поток сможет получить ресурс, эта задержка не может быть определена априори и в значительной степени зависит от количества конфликтов. Однако, примитивы синхронизации могут обеспечивать справедливость, гарантируя доступ всем потокам которые ожидают, также учитываю порядок.

// NSLock Нельзя использовать этот класс для реализации рекурсивной блокировки. Вызов lock метода дважды в том же потоке блокирует поток навсегда. Вместо этого нужно использовать класс для реализации рекурсивных локов. NSRecursiveLock - Возникает голодание

// NSRecursiveLock

